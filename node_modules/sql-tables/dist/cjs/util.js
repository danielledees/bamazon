"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk = require('chalk');
function arrToObj(arr, prop, aggregate) {
    return arr.reduce((state, el, i) => {
        let index;
        if (!prop) {
            index = i;
        }
        else {
            index = el[prop];
        }
        if (aggregate) {
            if (!state[index]) {
                state[index] = [];
            }
            state[index].push(el);
        }
        else {
            state[index] = el;
        }
        return state;
    }, {});
}
exports.arrToObj = arrToObj;
function objEach(d, callback) {
    Object.keys(d).forEach((key, i) => {
        callback(d[key], key, i, d);
    });
}
exports.objEach = objEach;
function objFilter(d, callback) {
    return objReduce(d, (state, value, key, index) => {
        if (callback(value, key, index)) {
            state[key] = value;
        }
        return state;
    }, {});
}
exports.objFilter = objFilter;
function objReduce(d, callback, init) {
    return Object.keys(d)
        .reduce((state, key, i) => {
        return callback(state, d[key], key, i, d);
    }, init);
}
exports.objReduce = objReduce;
/**
 *  If keys/values have different lengths the expect behavior is to "underflow"
 *  values.  Non values will be initialized to undefined. Non keys will be
 *  ignored.
 *
 *  If there are duplicate keys the last assignment "wins", this would be the
 *  key with the highest index in the given keys array
 */
function zip(keys, values) {
    return keys.reduce((o, key, i) => {
        o[key] = values[i];
        return o;
    }, {});
}
exports.zip = zip;
function unzip(dictionary) {
    return Object.keys(dictionary)
        .reduce((s, val) => {
        s.keys.push(val);
        s.values.push(dictionary[val]);
        return s;
    }, {
        keys: [],
        values: [],
    });
}
exports.unzip = unzip;
function toString(val) {
    return val + '';
}
exports.toString = toString;
function toStringMax(max, val) {
    const v = toString(val);
    return v.length > max ? v.slice(0, max) : v;
}
exports.toStringMax = toStringMax;
function toIntMin(min, val) {
    const num = toInt(val);
    if (num < min) {
        return min;
    }
    return num;
}
exports.toIntMin = toIntMin;
function toIntMax(max, val) {
    const num = toInt(val);
    if (num > max) {
        return max;
    }
    return num;
}
exports.toIntMax = toIntMax;
function toGtZeroIntMax(max, val) {
    const num = toInt(val);
    if (num > max) {
        return max;
    }
    if (num < 0) {
        return 0;
    }
    return num;
}
exports.toGtZeroIntMax = toGtZeroIntMax;
function partial(f, ...boundArg) {
    return (...args) => f(...boundArg, ...args);
}
exports.partial = partial;
function identity(i) {
    return i;
}
exports.identity = identity;
function toSqlBoolean(val) {
    if (val) {
        return 'TRUE';
    }
    return 'FALSE';
}
exports.toSqlBoolean = toSqlBoolean;
function toJsBoolean(val) {
    return val;
}
exports.toJsBoolean = toJsBoolean;
function toInt(val) {
    return parseInt(val, 10);
}
exports.toInt = toInt;
function toIntBetween(min, max, val) {
    const asInt = toInt(val);
    if (asInt < min) {
        return min;
    }
    if (asInt > max) {
        return max;
    }
    return asInt;
}
exports.toIntBetween = toIntBetween;
function toIntBetweenOptional(min, max, val) {
    if ((min === undefined) && (max === undefined)) {
        return val;
    }
    if (min === undefined) {
        return toIntMax(max, val);
    }
    if (max === undefined) {
        return toIntMin(min, val);
    }
    return toIntBetween(min, max, val);
}
exports.toIntBetweenOptional = toIntBetweenOptional;
function deepFreeze(obj) {
    if (Array.isArray(obj)) {
        return Object.freeze(obj.map(deepFreeze));
    }
    if (isObject(obj)) {
        for (let i in obj) {
            if (isObject(obj[i])) {
                if (!Object.isFrozen(obj[i])) {
                    obj[i] = deepFreeze(obj[i]);
                }
            }
        }
    }
    return Object.freeze(obj);
}
exports.deepFreeze = deepFreeze;
/**
 * Is the given value a truthy object?
 */
function isObject(obj) {
    if (!obj) {
        return false;
    }
    return typeof obj === 'object';
}
exports.isObject = isObject;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function error(...messages) {
    console.log.call(console, chalk.red(messages.join(' ')));
}
exports.error = error;
function sql(...messages) {
    if (process.env.SQLT_HIDE_SQL) {
        return;
    }
    console.log.call(console, chalk.blue(messages.join(' ')));
}
exports.sql = sql;
function log(...messages) {
    console.log.apply(console, messages);
}
exports.log = log;
function noop() { }
exports.noop = noop;
function nullableInt(val) {
    if (val === null) {
        return val;
    }
    return toInt(val);
}
exports.nullableInt = nullableInt;
function warn(...args) {
    console.warn.apply(console, args);
}
exports.warn = warn;
function isBoolean(arg) {
    if (typeof arg === 'boolean') {
        return true;
    }
    return false;
}
exports.isBoolean = isBoolean;
function findCaseInsensitivePropInObj(obj, prop) {
    const lProp = prop.toLowerCase();
    return objReduce(obj, (obj, el, objProp) => {
        if (obj) {
            return obj;
        }
        if (lProp === objProp.toLowerCase()) {
            return el;
        }
        return false;
    }, false);
}
exports.findCaseInsensitivePropInObj = findCaseInsensitivePropInObj;
function pluck(prop, haystack) {
    return haystack[prop];
}
exports.pluck = pluck;
function hasProp(prop, haystack) {
    return haystack[prop] ? true : false;
}
exports.hasProp = hasProp;
function augmentObjIfNew(obj, item, key) {
    if (obj[key]) {
        // skip over
        return obj;
    }
    obj[key] = item;
    return obj;
}
exports.augmentObjIfNew = augmentObjIfNew;
//# sourceMappingURL=util.js.map