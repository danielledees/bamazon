"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const schema_guards_1 = require("./schema/schema-guards");
const type_converters_1 = require("./type-converters");
const db_connect_1 = require("./db-connect");
const util_1 = require("./util");
exports.getClient = util_1.partial(getClientFrom, db_connect_1.pool);
exports.isValidResult = (result) => (result &&
    Array.isArray(result.rows) &&
    result.rows.length) ? true : false;
function getClientFrom(p) {
    return rxjs_1.Observable.create((obs) => {
        let cleanup = util_1.noop;
        p()
            .connect((err, client, done) => {
            cleanup = done;
            if (err) {
                obs.error(err);
                return;
            }
            obs.next(client);
            obs.complete();
        });
        return () => {
            if (cleanup) {
                cleanup();
            }
        };
    });
}
exports.getClientFrom = getClientFrom;
function createPgQuery(client, queryString, params) {
    if (params) {
        util_1.sql(`Run query: ${queryString} with params: ${params}`);
        return client.query(queryString, params);
    }
    util_1.sql(`Run query: ${queryString}`);
    return client.query(queryString);
}
exports.createPgQuery = createPgQuery;
/**
 * Internal function to create a query that returns an observable that emits
 * rows one at a time
 */
function createQueryStream(client, queryString, params) {
    return rxjs_1.Observable.create((obs) => {
        const qObj = createPgQuery(client, queryString, params);
        qObj.on('error', obs.error.bind(obs));
        qObj.on('row', obs.next.bind(obs));
        qObj.on('end', obs.complete.bind(obs));
    });
}
exports.createQueryStream = createQueryStream;
/**
 * Internal function to create a query that returns its _entire_ result as an
 * observable
 */
function createQueryObservable(client, queryString, params) {
    return rxjs_1.Observable.create((obs) => {
        const qp = createPgQuery(client, queryString, params);
        qp.then((result) => {
            obs.next(result);
            obs.complete();
        }, obs.error.bind(obs));
    });
}
exports.createQueryObservable = createQueryObservable;
function queryStream(queryString, params) {
    return exports.getClient()
        .flatMap((client) => createQueryStream(client, queryString, params));
}
exports.queryStream = queryStream;
function query(queryString, params) {
    return exports.getClient()
        .flatMap((client) => createQueryObservable(client, queryString, params));
}
exports.query = query;
function getStruct(schema, tableName) {
    return Object.assign({}, schema[tableName].struct);
}
exports.getStruct = getStruct;
function propSchemaToSql(prop, value) {
    let converted;
    if (type_converters_1.toSql[prop.type]) {
        converted = type_converters_1.toSql[prop.type](value);
    }
    if (type_converters_1.toGeneral[prop.type]) {
        converted = type_converters_1.toGeneral[prop.type](value);
    }
    if (util_1.isString(converted)) {
        if (prop.typeMax) {
            return converted.slice(0, prop.typeMax);
        }
        return converted;
    }
    return util_1.toIntBetweenOptional(prop.typeMin, prop.typeMax, value);
}
exports.propSchemaToSql = propSchemaToSql;
function propToSql(prop, value) {
    if (schema_guards_1.isSchemaType(prop)) {
        if (type_converters_1.toSql[prop]) {
            return type_converters_1.toSql[prop](value);
        }
        if (type_converters_1.toGeneral[prop]) {
            return type_converters_1.toGeneral[prop](value);
        }
        util_1.warn(`propToSql: no validator found for type ${prop}`);
        return '';
    }
    return propSchemaToSql(prop, value);
}
exports.propToSql = propToSql;
function validatePropValsForInput(struct, cols, vals) {
    return cols
        .reduce((state, prop, i) => {
        const item = struct[prop];
        if (item) {
            if (schema_guards_1.hasDbOnlyConstraints(item)) {
                // don't add it if it's db only
            }
            else {
                state.cols.push(prop);
                state.vals.push(propToSql(item, vals[i]));
            }
        }
        return state;
    }, {
        cols: [],
        vals: [],
    });
}
exports.validatePropValsForInput = validatePropValsForInput;
function createSelectWhereQuery(name, cols) {
    return `SELECT * FROM ${name} WHERE ` + cols
        .map((c, i) => `${c}=$${i + 1}`)
        .join(' AND ');
}
exports.createSelectWhereQuery = createSelectWhereQuery;
function createInsertQuery(name, cols, vals) {
    const colString = cols.join(', ');
    const valString = vals.reduce(makeParamReducer(cols.length), '');
    return `INSERT INTO ${name} (${colString}) VALUES ${valString}`;
}
exports.createInsertQuery = createInsertQuery;
function createUpdateQuery(name, cols, vals, idProps) {
    const inputs = cols.map((col, i) => `${col} = $${i + 1}`).join(', ');
    return `UPDATE ${name} SET ${inputs} WHERE ` + idProps.map((prop, i) => {
        return `${prop} = $${cols.length + i}`;
    }).join(' AND ');
}
exports.createUpdateQuery = createUpdateQuery;
function createDeleteQuery(name, idProps) {
    return `DELETE FROM ${name} WHERE ` + idProps.map((prop, i) => {
        return `${prop} = $${i}`;
    }).join(' AND ');
}
exports.createDeleteQuery = createDeleteQuery;
function createSelectAllQuery(name, cols = []) {
    if (cols.length) {
        return `SELECT ${cols.map(util_1.identity).join(', ')} FROM ${name}`;
    }
    else {
        return `SELECT * FROM ${name}`;
    }
}
exports.createSelectAllQuery = createSelectAllQuery;
function selectWhereValidator(schema, tableName, cols, vals) {
    if (cols.length !== vals.length) {
        return new Error('where: columns and values must pair up');
    }
    const tableSchema = getStruct(schema, tableName);
    if (!tableSchema) {
        return new Error(`where: table not found ${tableName}`);
    }
    return tableSchema;
}
exports.selectWhereValidator = selectWhereValidator;
/**
 * returns an observable that streams result rows
 */
function selectWhereStream(schema, tableName, cols, vals) {
    const tableSchema = selectWhereValidator(schema, tableName, cols, vals);
    if (tableSchema instanceof Error) {
        return rxjs_1.Observable.throw(tableSchema);
    }
    const validColVals = validatePropValsForInput(tableSchema, cols, vals);
    const q = createSelectWhereQuery(tableName, validColVals.cols);
    return queryStream(q, validColVals.vals);
}
exports.selectWhereStream = selectWhereStream;
function selectStream(schema, tableName, cols = []) {
    const q = createSelectAllQuery(tableName, cols);
    return queryStream(q);
}
exports.selectStream = selectStream;
/**
 * returns an observable with the _entire_ result
 */
function selectWhereObservable(schema, tableName, cols, vals) {
    const tableSchema = selectWhereValidator(schema, tableName, cols, vals);
    if (tableSchema instanceof Error) {
        return rxjs_1.Observable.throw(tableSchema);
    }
    const validColVals = validatePropValsForInput(tableSchema, cols, vals);
    const q = createSelectWhereQuery(tableName, validColVals.cols);
    return query(q, validColVals.vals);
}
exports.selectWhereObservable = selectWhereObservable;
function colsAndValsFromColsOrObject(colsOrObject, vals) {
    let cols;
    if (Array.isArray(colsOrObject)) {
        cols = colsOrObject;
        if (cols.length !== vals.length) {
            if (vals.length === 0 || (cols.length % vals.length !== 0)) {
                return rxjs_1.Observable
                    .throw(new Error('columns and values length must be the same or ' +
                    'vals must be a multiple of cols'));
            }
        }
    }
    else {
        cols = Object.keys(colsOrObject);
        vals = cols.map(col => colsOrObject[col]);
    }
    return {
        cols,
        vals,
    };
}
function insert(schema, tableName, colsOrObject, vals = []) {
    const cnv = colsAndValsFromColsOrObject(colsOrObject, vals);
    if (cnv instanceof rxjs_1.Observable) {
        return cnv;
    }
    const struct = getStruct(schema, tableName);
    if (!struct) {
        return rxjs_1.Observable.throw(new Error(`insert: table not found ${tableName}`));
    }
    const validColVals = validatePropValsForInput(struct, cnv.cols, cnv.vals);
    const q = createInsertQuery(tableName, validColVals.cols, validColVals.vals);
    util_1.sql('Attempting query', q);
    return query(q, validColVals.vals);
}
exports.insert = insert;
function update(schema, tableName, idProps, idValues, colsOrObject, vals = []) {
    const cnv = colsAndValsFromColsOrObject(colsOrObject, vals);
    if (cnv instanceof rxjs_1.Observable) {
        return cnv;
    }
    const struct = getStruct(schema, tableName);
    if (!struct) {
        return rxjs_1.Observable.throw(new Error(`insert: table not found ${tableName}`));
    }
    const validColVals = validatePropValsForInput(struct, cnv.cols, cnv.vals);
    const q = createUpdateQuery(tableName, validColVals.cols, validColVals.vals, idProps);
    util_1.sql('Attempting query', q);
    return query(q, validColVals.vals);
}
exports.update = update;
function deleteFrom(schema, tableName, idProps, idValues) {
    const struct = getStruct(schema, tableName);
    if (!struct) {
        return rxjs_1.Observable.throw(new Error(`insert: table not found ${tableName}`));
    }
    const q = createDeleteQuery(tableName, idProps);
    util_1.sql('Attempting query', q);
    return query(q, idValues);
}
exports.deleteFrom = deleteFrom;
function reduceByKeys(keys) {
    return (cols = [], col, i) => {
        if (keys.indexOf(i) === -1) {
            return cols;
        }
        cols.push(col);
        return cols;
    };
}
exports.reduceByKeys = reduceByKeys;
function hasQueryError(first, result, i) {
    if (first >= 0) {
        return first;
    }
    if (!result.length) {
        return i;
    }
    return first;
}
exports.hasQueryError = hasQueryError;
function createReduceCompoundInsertOrSelectResults(depCols) {
    return (results) => {
        const firstError = results.reduce(hasQueryError, -1);
        if (firstError !== -1) {
            throw new Error('compoundInsertOrSelect: failed on dependent query for ' +
                depCols[firstError]);
        }
        return results.map(r => r[0].id);
    };
}
exports.createReduceCompoundInsertOrSelectResults = createReduceCompoundInsertOrSelectResults;
function compoundInsertOrSelectIfExists(schema, tableName, cols, vals, depObservables, depCols, ...keyIndexes) {
    return rxjs_1.Observable
        .zip(...depObservables, (...deps) => deps)
        .map(createReduceCompoundInsertOrSelectResults(depCols))
        .flatMap((results) => insertOrSelectIfExistsObservable(schema, tableName, [...cols, ...depCols], [...vals, ...results], ...keyIndexes));
}
exports.compoundInsertOrSelectIfExists = compoundInsertOrSelectIfExists;
function insertOrSelectIfExistsObservable(schema, tableName, cols, vals, ...keyIndexes) {
    const reducedCols = cols.reduce(reduceByKeys(keyIndexes), []);
    const reducedVals = vals.reduce(reduceByKeys(keyIndexes), []);
    const swo = selectWhereObservable(schema, tableName, reducedCols, reducedVals);
    return swo.flatMap((result1) => exports.isValidResult(result1) ?
        rxjs_1.Observable.of(result1.rows) :
        insert(schema, tableName, cols, vals)
            .flatMap(() => swo
            .flatMap((result2) => exports.isValidResult(result2) ?
            rxjs_1.Observable.of(result2.rows) :
            rxjs_1.Observable.throw(new Error('insertOrSelectWhere: unknown fail')))));
}
exports.insertOrSelectIfExistsObservable = insertOrSelectIfExistsObservable;
function makeParamReducer(chunkSize) {
    return (vstr, v, i, arr) => {
        const pos = i + 1;
        if (arr.length === 1) {
            return `($${pos})`;
        }
        if (i === 0) {
            return `($${pos}`;
        }
        else if (i % chunkSize === 0) {
            return `${vstr}), ($${pos}`;
        }
        else if (i === arr.length - 1) {
            return `${vstr}, $${pos})`;
        }
        return `${vstr}, $${pos}`;
    };
}
function transactionStart(isolationLevel) {
    if (isolationLevel) {
        return query(`BEGIN TRANSACTION ISOLATION LEVEL ${isolationLevel};`);
    }
    return query('BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;');
}
exports.transactionStart = transactionStart;
function transactionEnd() {
    return query('END TRANSACTION;');
}
exports.transactionEnd = transactionEnd;
function transactionRollBack(err) {
    util_1.sql('Transaction Rollback', err ?
        err.message + '\nStack Trace: ' + err.stack :
        undefined);
    return query('ROLLBACK;');
}
exports.transactionRollBack = transactionRollBack;
function createCrud(schema) {
    return Object.keys(schema).reduce((crud, el) => {
        crud[el] = {
            insert: insert.bind(null, schema, el),
            update: update.bind(null, schema, el),
            delete: deleteFrom.bind(null, schema, el),
            select: selectStream.bind(null, schema, el),
            selectWhere: selectWhereStream.bind(null, schema, el),
        };
        return crud;
    }, {});
}
exports.createCrud = createCrud;
//# sourceMappingURL=table.js.map