export interface Dictionary<T> {
    [key: string]: T;
}
export declare function arrToObj<T>(arr: T[], prop?: string, aggregate?: boolean): Dictionary<T> | Dictionary<T[]>;
export declare function objEach<T>(d: Dictionary<T>, callback: (value: T, key?: string, index?: number, d?: Dictionary<T>) => any): void;
export declare function objFilter<T>(d: Dictionary<T>, callback: (value: T, key: string, index: number) => boolean): Dictionary<T>;
export declare function objReduce<T, R>(d: Dictionary<T>, callback: (state: R, value?: T, key?: string, index?: number, d?: Dictionary<T>) => R, init: R): R;
/**
 *  If keys/values have different lengths the expect behavior is to "underflow"
 *  values.  Non values will be initialized to undefined. Non keys will be
 *  ignored.
 *
 *  If there are duplicate keys the last assignment "wins", this would be the
 *  key with the highest index in the given keys array
 */
export declare function zip<T>(keys: string[], values: T[]): Dictionary<T>;
export declare function unzip<T>(dictionary: Dictionary<T>): {
    keys: string[];
    values: T[];
};
export declare function toString(val: any): string;
export declare function toStringMax(max: number, val: any): string;
export declare function toIntMin(min: number, val: any): number;
export declare function toIntMax(max: number, val: any): number;
export declare function toGtZeroIntMax(max: number, val: any): number;
export declare function partial<T>(f: Function, ...boundArg: any[]): (...args: any[]) => T;
export declare function identity<T>(i: any): T;
export declare function toSqlBoolean(val: boolean): string;
export declare function toJsBoolean(val: any): any;
export declare function toInt(val: any): number;
export declare function toIntBetween(min: number, max: number, val: any): number;
export declare function toIntBetweenOptional(min: number | undefined, max: number | undefined, val: number): number;
export declare function deepFreeze<T>(obj: T): T;
/**
 * Is the given value a truthy object?
 */
export declare function isObject(obj: any): obj is Object;
export declare function isString(input: any): input is string;
export declare function error(...messages: any[]): void;
export declare function sql(...messages: any[]): void;
export declare function log(...messages: any[]): void;
export declare function noop(): void;
export declare function nullableInt(val: any): any;
export declare function warn(...args: any[]): void;
export declare function isBoolean(arg: any): arg is boolean;
export declare function findCaseInsensitivePropInObj<T>(obj: Dictionary<T>, prop: string): T | boolean;
export declare function pluck<T>(prop: string, haystack: Dictionary<T>): T;
export declare function hasProp(prop: string, haystack: Dictionary<any>): boolean;
export declare function augmentObjIfNew<T>(obj: Dictionary<T>, item: T, key: string): Dictionary<T>;
