"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/operator/concat");
const util_1 = require("../../util");
const schema_1 = require("../schema");
const type_mappings_1 = require("../type-mappings");
const fixer_functions_1 = require("./fixer-functions");
function compareNullConstraints(col, constraints) {
    const index = constraints.indexOf('NotNull');
    if (col.is_nullable === 'YES') {
        if (index !== -1) {
            return {
                name: col.column_name,
                type: 'type',
                reason: schema_1.Constraint,
                extra: 'db: NULL code: NOT NULL',
            };
        }
    }
    else {
        if (index === -1) {
            return {
                name: col.column_name,
                type: 'type',
                reason: schema_1.Constraint,
                extra: 'db: NOT NULL code: NULL',
            };
        }
    }
    return null;
}
exports.compareNullConstraints = compareNullConstraints;
function compareTypes(type, col, constraints = []) {
    const mappings = type_mappings_1.typeMappingsByInfoSchema[col.data_type];
    if (Array.isArray(mappings)) {
        const match = mappings.reduce((state, el) => {
            if (state) {
                return state;
            }
            if (el.generic === type) {
                return true;
            }
            return false;
        }, false);
        if (!match) {
            return {
                name: col.column_name,
                type: 'type',
                reason: schema_1.TypeMismatch,
                extra: `db: ${col.data_type} code: ${type}`,
            };
        }
        return compareNullConstraints(col, constraints);
    }
    else {
        return {
            name: col.column_name,
            type: 'type',
            reason: schema_1.NotInCode,
        };
    }
}
exports.compareTypes = compareTypes;
function createSchemaValidationReducer(schema) {
    return (schemaState, scProp) => {
        return util_1.objReduce(scProp.struct, createStructValidationReducer(schema), schemaState);
    };
}
function validateSchemaRelations(schema) {
    const sSchema = fixer_functions_1.strictify(schema);
    return util_1.objReduce(sSchema, createSchemaValidationReducer(sSchema), { count: 0, string: '' }).string;
}
exports.validateSchemaRelations = validateSchemaRelations;
function createStructValidationReducer(schema) {
    return (structState, prop) => {
        if (prop.relation) {
            const relationError = findRelation(schema, prop.relation, prop.type);
            if (relationError) {
                return Object.assign({}, {
                    count: structState.count + 1,
                    string: structState.string ? '\n' + relationError : relationError,
                });
            }
        }
        return structState;
    };
}
function findRelation(s, r, type) {
    if (s[r.struct]) {
        const prop = s[r.struct].struct[r.prop];
        if (prop) {
            if (prop.type === type) {
                return '';
            }
            return `Prop ${r.prop} on ${r.struct} is of type ${prop.type} but ` +
                `relationship specifies ${type}`;
        }
        return `Prop ${r.prop} not found in Structure ${r.struct}`;
    }
    return `Structure "${r.struct}" not found`;
}
exports.findRelation = findRelation;
function typeCheckColumn(schemaStructProp, col) {
    const diff = compareTypes(schemaStructProp.type, col, schemaStructProp.constraints);
    if (diff) {
        diff.name = createColumnName(col.table_name, diff.name);
        return {
            error: diff,
            name: createColumnName(col.table_name, col.column_name),
        };
    }
    return {
        error: undefined,
        name: col.table_name + '.' + col.column_name,
    };
}
exports.typeCheckColumn = typeCheckColumn;
function createColumnName(tableName, columnName) {
    return `${tableName}.${columnName}`;
}
exports.createColumnName = createColumnName;
//# sourceMappingURL=checkers-types.js.map