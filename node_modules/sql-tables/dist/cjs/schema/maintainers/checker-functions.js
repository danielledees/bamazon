"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("rxjs/operator/concat");
const schema_1 = require("../schema");
const sql_1 = require("../queries/sql");
const schema_guards_1 = require("../schema-guards");
const util_1 = require("../../util");
const checkers_types_1 = require("./checkers-types");
const tableName = 'table_name';
const mapTableName = util_1.partial(util_1.pluck, tableName);
const hasTableName = util_1.partial(util_1.hasProp, tableName);
function listTableNames(query) {
    return sql_1.listTables(query)
        .filter(hasTableName)
        .map(mapTableName);
}
exports.listTableNames = listTableNames;
function fetchTablesAndCheckIfInCode(query, schema) {
    return listTableNames(query)
        .map(createCheckForTableInCode(schema))
        .toArray();
}
exports.fetchTablesAndCheckIfInCode = fetchTablesAndCheckIfInCode;
function findColumnInSchema(schema, table, column) {
    const scProp = util_1.findCaseInsensitivePropInObj(schema, table);
    if (util_1.isBoolean(scProp)) {
        return scProp;
    }
    return util_1.findCaseInsensitivePropInObj(scProp.struct, column);
}
exports.findColumnInSchema = findColumnInSchema;
function createInfoSchemaToValidationContainer(schema) {
    return (col) => {
        const c = findColumnInSchema(schema, col.table_name, col.column_name);
        if (schema_guards_1.isSchemaStructItem(c)) {
            return checkers_types_1.typeCheckColumn(c, col);
        }
        return {
            error: {
                name: checkers_types_1.createColumnName(col.table_name, col.column_name),
                reason: schema_1.NotInCode,
                type: 'column',
            },
            name: checkers_types_1.createColumnName(col.table_name, col.column_name),
        };
    };
}
exports.createInfoSchemaToValidationContainer = createInfoSchemaToValidationContainer;
function fetchColumnsAndCheckIfInCode(query, schema) {
    const filterByTable = (col) => util_1.findCaseInsensitivePropInObj(schema, col.table_name) ? true : false;
    return sql_1.listAllColumns(query)
        .filter(filterByTable)
        .map(createInfoSchemaToValidationContainer(schema))
        .toArray();
}
exports.fetchColumnsAndCheckIfInCode = fetchColumnsAndCheckIfInCode;
function createCheckForTableInCode(dict) {
    const keys = Object.keys(dict).map((k) => k.toLowerCase());
    return (collection) => {
        if (keys.indexOf(collection.toLowerCase()) === -1) {
            return {
                error: {
                    type: 'table',
                    name: collection,
                    reason: schema_1.NotInCode,
                },
                name: collection,
            };
        }
        const collDict = {};
        collDict[collection] = dict[collection];
        return {
            error: undefined,
            name: collection,
        };
    };
}
exports.createCheckForTableInCode = createCheckForTableInCode;
function checkForTableInDb(dict, dbTables) {
    const lcTables = dbTables.map(s => s.toLowerCase());
    return util_1.objReduce(dict, (state, schema, prop) => lcTables.indexOf(prop.toLowerCase()) === -1 ?
        state.concat([{
                type: 'table',
                name: prop,
                reason: schema_1.NotInDb,
            }]) :
        state, []);
}
exports.checkForTableInDb = checkForTableInDb;
function createColumnsInDbTableReducer(lcCols, sName) {
    return (innerState, colDesc, colProp) => {
        const needle = checkers_types_1.createColumnName(sName, colProp).toLowerCase();
        return lcCols.indexOf(needle) === -1 ?
            innerState.concat([{
                    type: 'column',
                    name: `${sName}.${colProp}`,
                    reason: schema_1.NotInDb,
                }]) :
            innerState;
    };
}
exports.createColumnsInDbTableReducer = createColumnsInDbTableReducer;
function createColumnsInDbReducer(dbColumns) {
    const lcCols = dbColumns.map(s => s.toLowerCase());
    return (state, scProp, prop) => util_1.objReduce(scProp.struct, createColumnsInDbTableReducer(lcCols, prop), state);
}
exports.createColumnsInDbReducer = createColumnsInDbReducer;
function checkForColumnInDb(dict, dbColumns) {
    return util_1.objReduce(dict, createColumnsInDbReducer(dbColumns), []);
}
exports.checkForColumnInDb = checkForColumnInDb;
function flattenSchemaValidationContainers(arr) {
    return arr.reduce((s, svc) => {
        if (svc.error) {
            s.errors.push(svc.error);
        }
        s.names.push(svc.name);
        return s;
    }, { errors: [], names: [] });
}
exports.flattenSchemaValidationContainers = flattenSchemaValidationContainers;
function validateColumns(query, schema, svc) {
    return fetchColumnsAndCheckIfInCode(query, schema)
        .map(flattenSchemaValidationContainers)
        .map((innerSvc) => checkForColumnInDb(schema, innerSvc.names)
        .concat(innerSvc.errors)
        .concat(svc.errors));
}
exports.validateColumns = validateColumns;
function validateTables(query, schema) {
    return fetchTablesAndCheckIfInCode(query, schema)
        .map(flattenSchemaValidationContainers)
        .map((svc) => ({
        errors: svc.errors.concat(checkForTableInDb(schema, svc.names)),
        names: svc.names,
    }));
}
exports.validateTables = validateTables;
//# sourceMappingURL=checker-functions.js.map