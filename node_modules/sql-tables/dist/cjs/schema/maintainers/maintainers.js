"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
require("rxjs/operator/concat");
const checker_functions_1 = require("./checker-functions");
const fixer_functions_1 = require("./fixer-functions");
const util_1 = require("../../util");
var fixer_functions_2 = require("./fixer-functions");
exports.mutateStructIntoSchemaStructs = fixer_functions_2.mutateStructIntoSchemaStructs;
function validateDatabase(query, schema) {
    return checker_functions_1.validateTables(query, schema)
        .flatMap((svc) => checker_functions_1.validateColumns(query, filterSchemaByTableValidations(schema, svc), svc));
}
exports.validateDatabase = validateDatabase;
function filterSchemaByTableValidations(schema, svc) {
    return util_1.objReduce(schema, (state, el, prop) => {
        if (svc.names.indexOf(prop.toLowerCase()) === -1) {
            state[prop] = el;
        }
        return state;
    }, {});
}
exports.filterSchemaByTableValidations = filterSchemaByTableValidations;
function orderedSchemaFromValidations(schema, validations) {
    const validationList = validations
        .map(exports.mapValidationTableNotInDb)
        .filter(Boolean);
    return fixer_functions_1.orderDependencies(schema)
        .filter((s) => validationList
        .indexOf(s.name) === -1 ? false : true);
}
exports.orderedSchemaFromValidations = orderedSchemaFromValidations;
function generateFixes(query, schema, validations, filterValidations, createValidationMapper) {
    const fixes = validations
        .filter(filterValidations)
        .map(createValidationMapper(query, schema));
    const balance = validations
        .filter((m) => !filterValidations(m));
    return {
        fixes,
        validations: balance,
    };
}
exports.generateFixes = generateFixes;
function nullFixMapper(query, schema) {
    return (sv) => {
        const [table, column] = sv.name.split('.');
        /**
         * This is a touch optimistic, but given validations are produced from the
         * schema their props should exist
         */
        const scProp = util_1.findCaseInsensitivePropInObj(schema, table);
        const prop = util_1.findCaseInsensitivePropInObj(scProp.struct, column);
        return fixer_functions_1.setColumnNullConstraint(query, table, column, prop);
    };
}
exports.nullFixMapper = nullFixMapper;
function columnAddMapper(query, schema) {
    return (sv) => {
        const [table, column] = sv.name.split('.');
        /**
         * This is a touch optimistic, but given validations are produced from the
         * schema their props should exist
         */
        try {
            const scProp = util_1.findCaseInsensitivePropInObj(schema, table);
            const prop = util_1.findCaseInsensitivePropInObj(scProp.struct, column);
            return fixer_functions_1.createColumn(query, table, column, prop);
        }
        catch (err) {
            util_1.log(`columnAddMapper: Known possible error path: ${sv.name}`, sv);
            throw err;
        }
    };
}
exports.columnAddMapper = columnAddMapper;
function createNotNullFilter(fixControls) {
    return (sv) => {
        if (fixControls.codeToDbNotNull && fixControls.codeToDbNull) {
            return sv.type === 'type' && sv.reason === 'constraint' &&
                (sv.extra === 'db: NULL code: NOT NULL' ||
                    sv.extra === 'db: NOT NULL code: NULL');
        }
        if (fixControls.codeToDbNotNull) {
            return sv.type === 'type' && sv.reason === 'constraint' &&
                sv.extra === 'db: NOT NULL code: NULL';
        }
        if (fixControls.codeToDbNull) {
            return sv.type === 'type' && sv.reason === 'constraint' &&
                sv.extra === 'db: NULL code: NOT NULL';
        }
        return false;
    };
}
exports.createNotNullFilter = createNotNullFilter;
function addNotNull(query, schema, validations, fixControls) {
    const nullFilter = createNotNullFilter(fixControls);
    return generateFixes(query, schema, validations, nullFilter, nullFixMapper);
}
exports.addNotNull = addNotNull;
function addColumns(query, schema, validations) {
    return generateFixes(query, schema, validations, (m) => m
        .type === 'column' && m.reason === 'not in db', columnAddMapper);
}
exports.addColumns = addColumns;
exports.mapValidationTableNotInDb = (sv) => sv
    .type === 'table' && sv.reason === 'not in db' ? sv.name : '';
/**
 * @todo refactor to match addColumn/notNull, interesting due to sort
 * constraints, in theory though we'll need sort constraints on columns :/
 */
function addTables(query, schema, validations) {
    const tables = validations
        .map(exports.mapValidationTableNotInDb)
        .filter(Boolean);
    const columns = validations
        .filter((m) => {
        if (m.type === 'table') {
            return null;
        }
        // filter for missing columns on added tables
        const tIndex = tables.indexOf(m.name.split('.')[0]);
        if (tIndex === -1) {
            return m;
        }
        return null;
    })
        .filter(Boolean);
    const orderedSchemaFixes = orderedSchemaFromValidations(schema, validations);
    return {
        fixes: orderedSchemaFixes
            .map((osf) => fixer_functions_1.createTableFromStruct(query, osf.name, osf.scProp)),
        validations: columns,
    };
}
exports.addTables = addTables;
function fixValidations(query, schema, fixControls) {
    return (validations) => {
        if (fixControls.additive) {
            const tableResult = addTables(query, schema, validations);
            const columnResult = addColumns(query, schema, tableResult.validations);
            const notNulResults = addNotNull(query, schema, columnResult.validations, fixControls);
            return {
                fixes: [
                    ...tableResult.fixes,
                    ...columnResult.fixes,
                    ...notNulResults.fixes,
                ],
                validations: notNulResults.validations
            };
        }
        else {
            return {
                fixes: [],
                validations,
            };
        }
    };
}
exports.fixValidations = fixValidations;
function validateAndFixDatabase(query, schema, fixControls = {
    additive: true,
    codeToDbNotNull: true,
    codeToDbNull: false,
}) {
    return validateDatabase(query, schema)
        .map(fixValidations(query, schema, fixControls))
        .flatMap((vfc) => {
        return rxjs_1.Observable
            .concat(...vfc.fixes)
            .toArray()
            .map(() => vfc.validations);
    });
}
exports.validateAndFixDatabase = validateAndFixDatabase;
//# sourceMappingURL=maintainers.js.map