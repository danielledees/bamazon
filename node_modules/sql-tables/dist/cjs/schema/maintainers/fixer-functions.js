"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schema_guards_1 = require("../schema-guards");
const sql_1 = require("../queries/sql");
const type_mappings_1 = require("../type-mappings");
const util_1 = require("../../util");
const MAX_VAR_CHAR = 255;
function createColumn(query, table, column, prop) {
    const columnString = createColumnFromProp(column, prop);
    return query(`${sql_1.addColumn(table)} ${columnString}`);
}
exports.createColumn = createColumn;
function setColumnNullConstraint(query, table, column, prop) {
    if (schema_guards_1.hasConstraint('NotNull', prop)) {
        return query(sql_1.setNotNull(table, column));
    }
    return query(sql_1.setNull(table, column));
}
exports.setColumnNullConstraint = setColumnNullConstraint;
function createAutomaticColumnNameType(name, type) {
    if (type_mappings_1.automatics[type]) {
        return `${name} ${type_mappings_1.automatics[type]}`;
    }
    util_1.log(`Unexpected: createColumnFromItem: Unsupported automatic type ${type}`);
    return '';
}
exports.createAutomaticColumnNameType = createAutomaticColumnNameType;
function createColumnFromProp(name, prop) {
    const type = prop.type;
    if (exports.isAutomatic(prop)) {
        return createAutomaticColumnNameType(name, type);
    }
    if (!type_mappings_1.typeMappingsByGeneric[type]) {
        util_1.log(`Unexpected createColumnFromItem: Unsupported type ${type}`);
        return '';
    }
    const mapping = type_mappings_1.typeMappingsByGeneric[type];
    if (mapping.create) {
        return `${name} ${mapping.create} ${createConstraints(prop)} ` +
            `${createReferences(prop)}`;
    }
    let evaluatedType = mapping.createA;
    if (type === 'String' && schema_guards_1.isSchemaStructProp(prop)) {
        evaluatedType = sql_1.varChar(prop.typeMax || MAX_VAR_CHAR);
    }
    else {
        util_1.log(`Unexpected createColumnFromItem: Unsupported argument type ${type}`);
        return '';
    }
    return `${name} ${evaluatedType} ${createConstraints(prop)} ` +
        `${createReferences(prop)} ${createDefault(prop)}`;
}
exports.createColumnFromProp = createColumnFromProp;
function createTableFromStruct(query, name, s) {
    return sql_1.createTable(query, name, util_1.objReduce(s.struct, (state, el, name) => {
        const column = createColumnFromProp(name, el).trim();
        if (column) {
            state.push(column);
        }
        return state;
    }, [])
        .concat(createCompositeConstraints(s)));
}
exports.createTableFromStruct = createTableFromStruct;
function createCompositeConstraints(scProp) {
    return [
        ...createCompositeUnique(scProp),
        ...createCompositeForeignKey(scProp),
        createCompositePrimaryKey(scProp),
    ].filter(Boolean);
}
exports.createCompositeConstraints = createCompositeConstraints;
function createCompositeUnique(scProp) {
    if (Array.isArray(scProp.unique) && scProp.unique.length) {
        return scProp.unique.map(sql_1.unique);
    }
    return [];
}
exports.createCompositeUnique = createCompositeUnique;
function createCompositeForeignKey(scProp) {
    if (Array.isArray(scProp.foreignKey) && scProp.foreignKey.length) {
        return scProp.foreignKey
            .map((scr) => sql_1.foreignKeyComposite(scr.props, scr.propsForeign, scr.struct));
    }
    return [];
}
exports.createCompositeForeignKey = createCompositeForeignKey;
function createCompositePrimaryKey(scProp) {
    if (Array.isArray(scProp.primaryKey) && scProp.primaryKey.length) {
        return sql_1.primaryKey(scProp.primaryKey);
    }
    return '';
}
exports.createCompositePrimaryKey = createCompositePrimaryKey;
function createConstraints(item) {
    if (schema_guards_1.hasConstraints(item)) {
        return item.constraints
            .reduce((s, c) => {
            if (type_mappings_1.appOnlyMappings.indexOf(c) !== -1) {
                return s;
            }
            const mapping = type_mappings_1.constraintMappingsByGeneric[c];
            if (!mapping || (!mapping.create)) {
                util_1.log(`Unexpected: createConstraints: Unsupported mapping ${c}`);
                return s;
            }
            return s + mapping.create + ' ';
        }, '');
    }
    return '';
}
exports.createConstraints = createConstraints;
function createReferences(item) {
    if (item.relation) {
        return sql_1.foreignKey(item.relation.struct, item.relation.prop).trim();
    }
    else {
        return '';
    }
}
exports.createReferences = createReferences;
function createDefault(prop) {
    if (prop.defaultValue) {
        return `DEFAULT ${prop.defaultValue}`;
    }
    else {
        return '';
    }
}
exports.createDefault = createDefault;
function isConstraint(constraint, item) {
    if (schema_guards_1.hasConstraints(item)) {
        return item.constraints
            .reduce((s, c) => c === constraint ? true : s, false);
    }
    return false;
}
exports.isConstraint = isConstraint;
exports.isAutomatic = util_1.partial(isConstraint, 'Automatic');
function orderDependencies(schema) {
    return util_1.objReduce(schema, createCrIterator(schema), {
        result: [],
        checked: {},
        ancestors: [],
    }).result;
}
exports.orderDependencies = orderDependencies;
function createCrIterator(schema) {
    return function schemaIterator(state, scProp, key) {
        // skip rows that have already been checked
        if (state.checked[key]) {
            return state;
        }
        // stack up lineage to check circular dependencies
        state.ancestors.push(key);
        // mark row as checked
        state.checked[key] = true;
        state = util_1.objReduce(scProp.struct, createStructIterator(schema, schemaIterator, key), state);
        // add result, and fix up the stack
        state.result.push({
            name: key,
            scProp,
        });
        state.ancestors.pop();
        // check each requirement too
        return state;
    };
}
exports.createCrIterator = createCrIterator;
function createStructIterator(schema, schemaIterator, key) {
    return (state, item) => {
        // skip items with no relationships
        if (!item.relation) {
            return state;
        }
        const dependsOn = item.relation.struct;
        if (state.ancestors.indexOf(dependsOn) > -1) {
            throw new Error('DB Fixer: circular dependency found: ' + key +
                ' -> ' + dependsOn);
        }
        if (state.checked[dependsOn]) {
            return state;
        }
        if (!schema[dependsOn]) {
            throw new ReferenceError('DB Fixer: unable to resolve: ' + dependsOn);
        }
        schemaIterator(state, schema[dependsOn], dependsOn);
        return state;
    };
}
exports.createStructIterator = createStructIterator;
function strictifySchemaStructItem(scItem) {
    if (schema_guards_1.isSchemaType(scItem)) {
        return {
            type: scItem,
        };
    }
    return scItem;
}
exports.strictifySchemaStructItem = strictifySchemaStructItem;
function strictifySchemaStruct(struct) {
    return util_1.objReduce(struct, (s, e, i) => {
        s[i] = strictifySchemaStructItem(e);
        return s;
    }, {});
}
exports.strictifySchemaStruct = strictifySchemaStruct;
function strictifySchemaItem(scProp) {
    if (schema_guards_1.isSchemaProp(scProp)) {
        if (schema_guards_1.isSchemaStructStrict(scProp.struct)) {
            return scProp;
        }
        return Object.assign({}, scProp, {
            struct: strictifySchemaStruct(scProp.struct),
        });
    }
    return {
        struct: strictifySchemaStruct(scProp),
    };
}
exports.strictifySchemaItem = strictifySchemaItem;
function strictify(schema) {
    return util_1.objReduce(schema, (s, e, i) => {
        s[i] = strictifySchemaItem(e);
        return s;
    }, {});
}
exports.strictify = strictify;
function mutateStructIntoSchemaStructs(s, schema) {
    return util_1.objReduce(schema, (newSchema, item) => {
        const struct = item.struct ? item.struct : item;
        util_1.objReduce(s, util_1.augmentObjIfNew, struct);
        return newSchema;
    }, schema);
}
exports.mutateStructIntoSchemaStructs = mutateStructIntoSchemaStructs;
//# sourceMappingURL=fixer-functions.js.map