import { Observable } from 'rxjs';
import { hasDbOnlyConstraints, isSchemaType, } from './schema/schema-guards';
import { toGeneral, toSql } from './type-converters';
import { pool } from './db-connect';
import { isString, noop, partial, sql, warn, toIntBetweenOptional, identity, } from './util';
export const getClient = partial(getClientFrom, pool);
export const isValidResult = (result) => (result &&
    Array.isArray(result.rows) &&
    result.rows.length) ? true : false;
export function getClientFrom(p) {
    return Observable.create((obs) => {
        let cleanup = noop;
        p()
            .connect((err, client, done) => {
            cleanup = done;
            if (err) {
                obs.error(err);
                return;
            }
            obs.next(client);
            obs.complete();
        });
        return () => {
            if (cleanup) {
                cleanup();
            }
        };
    });
}
export function createPgQuery(client, queryString, params) {
    if (params) {
        sql(`Run query: ${queryString} with params: ${params}`);
        return client.query(queryString, params);
    }
    sql(`Run query: ${queryString}`);
    return client.query(queryString);
}
/**
 * Internal function to create a query that returns an observable that emits
 * rows one at a time
 */
export function createQueryStream(client, queryString, params) {
    return Observable.create((obs) => {
        const qObj = createPgQuery(client, queryString, params);
        qObj.on('error', obs.error.bind(obs));
        qObj.on('row', obs.next.bind(obs));
        qObj.on('end', obs.complete.bind(obs));
    });
}
/**
 * Internal function to create a query that returns its _entire_ result as an
 * observable
 */
export function createQueryObservable(client, queryString, params) {
    return Observable.create((obs) => {
        const qp = createPgQuery(client, queryString, params);
        qp.then((result) => {
            obs.next(result);
            obs.complete();
        }, obs.error.bind(obs));
    });
}
export function queryStream(queryString, params) {
    return getClient()
        .flatMap((client) => createQueryStream(client, queryString, params));
}
export function query(queryString, params) {
    return getClient()
        .flatMap((client) => createQueryObservable(client, queryString, params));
}
export function getStruct(schema, tableName) {
    return Object.assign({}, schema[tableName].struct);
}
export function propSchemaToSql(prop, value) {
    let converted;
    if (toSql[prop.type]) {
        converted = toSql[prop.type](value);
    }
    if (toGeneral[prop.type]) {
        converted = toGeneral[prop.type](value);
    }
    if (isString(converted)) {
        if (prop.typeMax) {
            return converted.slice(0, prop.typeMax);
        }
        return converted;
    }
    return toIntBetweenOptional(prop.typeMin, prop.typeMax, value);
}
export function propToSql(prop, value) {
    if (isSchemaType(prop)) {
        if (toSql[prop]) {
            return toSql[prop](value);
        }
        if (toGeneral[prop]) {
            return toGeneral[prop](value);
        }
        warn(`propToSql: no validator found for type ${prop}`);
        return '';
    }
    return propSchemaToSql(prop, value);
}
export function validatePropValsForInput(struct, cols, vals) {
    return cols
        .reduce((state, prop, i) => {
        const item = struct[prop];
        if (item) {
            if (hasDbOnlyConstraints(item)) {
                // don't add it if it's db only
            }
            else {
                state.cols.push(prop);
                state.vals.push(propToSql(item, vals[i]));
            }
        }
        return state;
    }, {
        cols: [],
        vals: [],
    });
}
export function createSelectWhereQuery(name, cols) {
    return `SELECT * FROM ${name} WHERE ` + cols
        .map((c, i) => `${c}=$${i + 1}`)
        .join(' AND ');
}
export function createInsertQuery(name, cols, vals) {
    const colString = cols.join(', ');
    const valString = vals.reduce(makeParamReducer(cols.length), '');
    return `INSERT INTO ${name} (${colString}) VALUES ${valString}`;
}
export function createUpdateQuery(name, cols, vals, idProps) {
    const inputs = cols.map((col, i) => `${col} = $${i + 1}`).join(', ');
    return `UPDATE ${name} SET ${inputs} WHERE ` + idProps.map((prop, i) => {
        return `${prop} = $${cols.length + i}`;
    }).join(' AND ');
}
export function createDeleteQuery(name, idProps) {
    return `DELETE FROM ${name} WHERE ` + idProps.map((prop, i) => {
        return `${prop} = $${i}`;
    }).join(' AND ');
}
export function createSelectAllQuery(name, cols = []) {
    if (cols.length) {
        return `SELECT ${cols.map(identity).join(', ')} FROM ${name}`;
    }
    else {
        return `SELECT * FROM ${name}`;
    }
}
export function selectWhereValidator(schema, tableName, cols, vals) {
    if (cols.length !== vals.length) {
        return new Error('where: columns and values must pair up');
    }
    const tableSchema = getStruct(schema, tableName);
    if (!tableSchema) {
        return new Error(`where: table not found ${tableName}`);
    }
    return tableSchema;
}
/**
 * returns an observable that streams result rows
 */
export function selectWhereStream(schema, tableName, cols, vals) {
    const tableSchema = selectWhereValidator(schema, tableName, cols, vals);
    if (tableSchema instanceof Error) {
        return Observable.throw(tableSchema);
    }
    const validColVals = validatePropValsForInput(tableSchema, cols, vals);
    const q = createSelectWhereQuery(tableName, validColVals.cols);
    return queryStream(q, validColVals.vals);
}
export function selectStream(schema, tableName, cols = []) {
    const q = createSelectAllQuery(tableName, cols);
    return queryStream(q);
}
/**
 * returns an observable with the _entire_ result
 */
export function selectWhereObservable(schema, tableName, cols, vals) {
    const tableSchema = selectWhereValidator(schema, tableName, cols, vals);
    if (tableSchema instanceof Error) {
        return Observable.throw(tableSchema);
    }
    const validColVals = validatePropValsForInput(tableSchema, cols, vals);
    const q = createSelectWhereQuery(tableName, validColVals.cols);
    return query(q, validColVals.vals);
}
function colsAndValsFromColsOrObject(colsOrObject, vals) {
    let cols;
    if (Array.isArray(colsOrObject)) {
        cols = colsOrObject;
        if (cols.length !== vals.length) {
            if (vals.length === 0 || (cols.length % vals.length !== 0)) {
                return Observable
                    .throw(new Error('columns and values length must be the same or ' +
                    'vals must be a multiple of cols'));
            }
        }
    }
    else {
        cols = Object.keys(colsOrObject);
        vals = cols.map(col => colsOrObject[col]);
    }
    return {
        cols,
        vals,
    };
}
export function insert(schema, tableName, colsOrObject, vals = []) {
    const cnv = colsAndValsFromColsOrObject(colsOrObject, vals);
    if (cnv instanceof Observable) {
        return cnv;
    }
    const struct = getStruct(schema, tableName);
    if (!struct) {
        return Observable.throw(new Error(`insert: table not found ${tableName}`));
    }
    const validColVals = validatePropValsForInput(struct, cnv.cols, cnv.vals);
    const q = createInsertQuery(tableName, validColVals.cols, validColVals.vals);
    sql('Attempting query', q);
    return query(q, validColVals.vals);
}
export function update(schema, tableName, idProps, idValues, colsOrObject, vals = []) {
    const cnv = colsAndValsFromColsOrObject(colsOrObject, vals);
    if (cnv instanceof Observable) {
        return cnv;
    }
    const struct = getStruct(schema, tableName);
    if (!struct) {
        return Observable.throw(new Error(`insert: table not found ${tableName}`));
    }
    const validColVals = validatePropValsForInput(struct, cnv.cols, cnv.vals);
    const q = createUpdateQuery(tableName, validColVals.cols, validColVals.vals, idProps);
    sql('Attempting query', q);
    return query(q, validColVals.vals);
}
export function deleteFrom(schema, tableName, idProps, idValues) {
    const struct = getStruct(schema, tableName);
    if (!struct) {
        return Observable.throw(new Error(`insert: table not found ${tableName}`));
    }
    const q = createDeleteQuery(tableName, idProps);
    sql('Attempting query', q);
    return query(q, idValues);
}
export function reduceByKeys(keys) {
    return (cols = [], col, i) => {
        if (keys.indexOf(i) === -1) {
            return cols;
        }
        cols.push(col);
        return cols;
    };
}
export function hasQueryError(first, result, i) {
    if (first >= 0) {
        return first;
    }
    if (!result.length) {
        return i;
    }
    return first;
}
export function createReduceCompoundInsertOrSelectResults(depCols) {
    return (results) => {
        const firstError = results.reduce(hasQueryError, -1);
        if (firstError !== -1) {
            throw new Error('compoundInsertOrSelect: failed on dependent query for ' +
                depCols[firstError]);
        }
        return results.map(r => r[0].id);
    };
}
export function compoundInsertOrSelectIfExists(schema, tableName, cols, vals, depObservables, depCols, ...keyIndexes) {
    return Observable
        .zip(...depObservables, (...deps) => deps)
        .map(createReduceCompoundInsertOrSelectResults(depCols))
        .flatMap((results) => insertOrSelectIfExistsObservable(schema, tableName, [...cols, ...depCols], [...vals, ...results], ...keyIndexes));
}
export function insertOrSelectIfExistsObservable(schema, tableName, cols, vals, ...keyIndexes) {
    const reducedCols = cols.reduce(reduceByKeys(keyIndexes), []);
    const reducedVals = vals.reduce(reduceByKeys(keyIndexes), []);
    const swo = selectWhereObservable(schema, tableName, reducedCols, reducedVals);
    return swo.flatMap((result1) => isValidResult(result1) ?
        Observable.of(result1.rows) :
        insert(schema, tableName, cols, vals)
            .flatMap(() => swo
            .flatMap((result2) => isValidResult(result2) ?
            Observable.of(result2.rows) :
            Observable.throw(new Error('insertOrSelectWhere: unknown fail')))));
}
function makeParamReducer(chunkSize) {
    return (vstr, v, i, arr) => {
        const pos = i + 1;
        if (arr.length === 1) {
            return `($${pos})`;
        }
        if (i === 0) {
            return `($${pos}`;
        }
        else if (i % chunkSize === 0) {
            return `${vstr}), ($${pos}`;
        }
        else if (i === arr.length - 1) {
            return `${vstr}, $${pos})`;
        }
        return `${vstr}, $${pos}`;
    };
}
export function transactionStart(isolationLevel) {
    if (isolationLevel) {
        return query(`BEGIN TRANSACTION ISOLATION LEVEL ${isolationLevel};`);
    }
    return query('BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;');
}
export function transactionEnd() {
    return query('END TRANSACTION;');
}
export function transactionRollBack(err) {
    sql('Transaction Rollback', err ?
        err.message + '\nStack Trace: ' + err.stack :
        undefined);
    return query('ROLLBACK;');
}
export function createCrud(schema) {
    return Object.keys(schema).reduce((crud, el) => {
        crud[el] = {
            insert: insert.bind(null, schema, el),
            update: update.bind(null, schema, el),
            delete: deleteFrom.bind(null, schema, el),
            select: selectStream.bind(null, schema, el),
            selectWhere: selectWhereStream.bind(null, schema, el),
        };
        return crud;
    }, {});
}
//# sourceMappingURL=table.js.map