import { Observable } from 'rxjs';
import 'rxjs/operator/concat';
import { validateColumns, validateTables } from './checker-functions';
import { createColumn, createTableFromStruct, orderDependencies, setColumnNullConstraint, } from './fixer-functions';
import { findCaseInsensitivePropInObj, log, objReduce } from '../../util';
export { mutateStructIntoSchemaStructs } from './fixer-functions';
export function validateDatabase(query, schema) {
    return validateTables(query, schema)
        .flatMap((svc) => validateColumns(query, filterSchemaByTableValidations(schema, svc), svc));
}
export function filterSchemaByTableValidations(schema, svc) {
    return objReduce(schema, (state, el, prop) => {
        if (svc.names.indexOf(prop.toLowerCase()) === -1) {
            state[prop] = el;
        }
        return state;
    }, {});
}
export function orderedSchemaFromValidations(schema, validations) {
    const validationList = validations
        .map(mapValidationTableNotInDb)
        .filter(Boolean);
    return orderDependencies(schema)
        .filter((s) => validationList
        .indexOf(s.name) === -1 ? false : true);
}
export function generateFixes(query, schema, validations, filterValidations, createValidationMapper) {
    const fixes = validations
        .filter(filterValidations)
        .map(createValidationMapper(query, schema));
    const balance = validations
        .filter((m) => !filterValidations(m));
    return {
        fixes,
        validations: balance,
    };
}
export function nullFixMapper(query, schema) {
    return (sv) => {
        const [table, column] = sv.name.split('.');
        /**
         * This is a touch optimistic, but given validations are produced from the
         * schema their props should exist
         */
        const scProp = findCaseInsensitivePropInObj(schema, table);
        const prop = findCaseInsensitivePropInObj(scProp.struct, column);
        return setColumnNullConstraint(query, table, column, prop);
    };
}
export function columnAddMapper(query, schema) {
    return (sv) => {
        const [table, column] = sv.name.split('.');
        /**
         * This is a touch optimistic, but given validations are produced from the
         * schema their props should exist
         */
        try {
            const scProp = findCaseInsensitivePropInObj(schema, table);
            const prop = findCaseInsensitivePropInObj(scProp.struct, column);
            return createColumn(query, table, column, prop);
        }
        catch (err) {
            log(`columnAddMapper: Known possible error path: ${sv.name}`, sv);
            throw err;
        }
    };
}
export function createNotNullFilter(fixControls) {
    return (sv) => {
        if (fixControls.codeToDbNotNull && fixControls.codeToDbNull) {
            return sv.type === 'type' && sv.reason === 'constraint' &&
                (sv.extra === 'db: NULL code: NOT NULL' ||
                    sv.extra === 'db: NOT NULL code: NULL');
        }
        if (fixControls.codeToDbNotNull) {
            return sv.type === 'type' && sv.reason === 'constraint' &&
                sv.extra === 'db: NOT NULL code: NULL';
        }
        if (fixControls.codeToDbNull) {
            return sv.type === 'type' && sv.reason === 'constraint' &&
                sv.extra === 'db: NULL code: NOT NULL';
        }
        return false;
    };
}
export function addNotNull(query, schema, validations, fixControls) {
    const nullFilter = createNotNullFilter(fixControls);
    return generateFixes(query, schema, validations, nullFilter, nullFixMapper);
}
export function addColumns(query, schema, validations) {
    return generateFixes(query, schema, validations, (m) => m
        .type === 'column' && m.reason === 'not in db', columnAddMapper);
}
export const mapValidationTableNotInDb = (sv) => sv
    .type === 'table' && sv.reason === 'not in db' ? sv.name : '';
/**
 * @todo refactor to match addColumn/notNull, interesting due to sort
 * constraints, in theory though we'll need sort constraints on columns :/
 */
export function addTables(query, schema, validations) {
    const tables = validations
        .map(mapValidationTableNotInDb)
        .filter(Boolean);
    const columns = validations
        .filter((m) => {
        if (m.type === 'table') {
            return null;
        }
        // filter for missing columns on added tables
        const tIndex = tables.indexOf(m.name.split('.')[0]);
        if (tIndex === -1) {
            return m;
        }
        return null;
    })
        .filter(Boolean);
    const orderedSchemaFixes = orderedSchemaFromValidations(schema, validations);
    return {
        fixes: orderedSchemaFixes
            .map((osf) => createTableFromStruct(query, osf.name, osf.scProp)),
        validations: columns,
    };
}
export function fixValidations(query, schema, fixControls) {
    return (validations) => {
        if (fixControls.additive) {
            const tableResult = addTables(query, schema, validations);
            const columnResult = addColumns(query, schema, tableResult.validations);
            const notNulResults = addNotNull(query, schema, columnResult.validations, fixControls);
            return {
                fixes: [
                    ...tableResult.fixes,
                    ...columnResult.fixes,
                    ...notNulResults.fixes,
                ],
                validations: notNulResults.validations
            };
        }
        else {
            return {
                fixes: [],
                validations,
            };
        }
    };
}
export function validateAndFixDatabase(query, schema, fixControls = {
    additive: true,
    codeToDbNotNull: true,
    codeToDbNull: false,
}) {
    return validateDatabase(query, schema)
        .map(fixValidations(query, schema, fixControls))
        .flatMap((vfc) => {
        return Observable
            .concat(...vfc.fixes)
            .toArray()
            .map(() => vfc.validations);
    });
}
//# sourceMappingURL=maintainers.js.map