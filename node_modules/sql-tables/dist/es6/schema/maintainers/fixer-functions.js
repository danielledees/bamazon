import { hasConstraints, hasConstraint, isSchemaProp, isSchemaStructProp, isSchemaStructStrict, isSchemaType, } from '../schema-guards';
import { addColumn, createTable, foreignKey, foreignKeyComposite, primaryKey, setNotNull, setNull, unique, varChar, } from '../queries/sql';
import { automatics, constraintMappingsByGeneric, appOnlyMappings, typeMappingsByGeneric, } from '../type-mappings';
import { augmentObjIfNew, log, partial, objReduce, } from '../../util';
const MAX_VAR_CHAR = 255;
export function createColumn(query, table, column, prop) {
    const columnString = createColumnFromProp(column, prop);
    return query(`${addColumn(table)} ${columnString}`);
}
export function setColumnNullConstraint(query, table, column, prop) {
    if (hasConstraint('NotNull', prop)) {
        return query(setNotNull(table, column));
    }
    return query(setNull(table, column));
}
export function createAutomaticColumnNameType(name, type) {
    if (automatics[type]) {
        return `${name} ${automatics[type]}`;
    }
    log(`Unexpected: createColumnFromItem: Unsupported automatic type ${type}`);
    return '';
}
export function createColumnFromProp(name, prop) {
    const type = prop.type;
    if (isAutomatic(prop)) {
        return createAutomaticColumnNameType(name, type);
    }
    if (!typeMappingsByGeneric[type]) {
        log(`Unexpected createColumnFromItem: Unsupported type ${type}`);
        return '';
    }
    const mapping = typeMappingsByGeneric[type];
    if (mapping.create) {
        return `${name} ${mapping.create} ${createConstraints(prop)} ` +
            `${createReferences(prop)}`;
    }
    let evaluatedType = mapping.createA;
    if (type === 'String' && isSchemaStructProp(prop)) {
        evaluatedType = varChar(prop.typeMax || MAX_VAR_CHAR);
    }
    else {
        log(`Unexpected createColumnFromItem: Unsupported argument type ${type}`);
        return '';
    }
    return `${name} ${evaluatedType} ${createConstraints(prop)} ` +
        `${createReferences(prop)} ${createDefault(prop)}`;
}
export function createTableFromStruct(query, name, s) {
    return createTable(query, name, objReduce(s.struct, (state, el, name) => {
        const column = createColumnFromProp(name, el).trim();
        if (column) {
            state.push(column);
        }
        return state;
    }, [])
        .concat(createCompositeConstraints(s)));
}
export function createCompositeConstraints(scProp) {
    return [
        ...createCompositeUnique(scProp),
        ...createCompositeForeignKey(scProp),
        createCompositePrimaryKey(scProp),
    ].filter(Boolean);
}
export function createCompositeUnique(scProp) {
    if (Array.isArray(scProp.unique) && scProp.unique.length) {
        return scProp.unique.map(unique);
    }
    return [];
}
export function createCompositeForeignKey(scProp) {
    if (Array.isArray(scProp.foreignKey) && scProp.foreignKey.length) {
        return scProp.foreignKey
            .map((scr) => foreignKeyComposite(scr.props, scr.propsForeign, scr.struct));
    }
    return [];
}
export function createCompositePrimaryKey(scProp) {
    if (Array.isArray(scProp.primaryKey) && scProp.primaryKey.length) {
        return primaryKey(scProp.primaryKey);
    }
    return '';
}
export function createConstraints(item) {
    if (hasConstraints(item)) {
        return item.constraints
            .reduce((s, c) => {
            if (appOnlyMappings.indexOf(c) !== -1) {
                return s;
            }
            const mapping = constraintMappingsByGeneric[c];
            if (!mapping || (!mapping.create)) {
                log(`Unexpected: createConstraints: Unsupported mapping ${c}`);
                return s;
            }
            return s + mapping.create + ' ';
        }, '');
    }
    return '';
}
export function createReferences(item) {
    if (item.relation) {
        return foreignKey(item.relation.struct, item.relation.prop).trim();
    }
    else {
        return '';
    }
}
export function createDefault(prop) {
    if (prop.defaultValue) {
        return `DEFAULT ${prop.defaultValue}`;
    }
    else {
        return '';
    }
}
export function isConstraint(constraint, item) {
    if (hasConstraints(item)) {
        return item.constraints
            .reduce((s, c) => c === constraint ? true : s, false);
    }
    return false;
}
export const isAutomatic = partial(isConstraint, 'Automatic');
export function orderDependencies(schema) {
    return objReduce(schema, createCrIterator(schema), {
        result: [],
        checked: {},
        ancestors: [],
    }).result;
}
export function createCrIterator(schema) {
    return function schemaIterator(state, scProp, key) {
        // skip rows that have already been checked
        if (state.checked[key]) {
            return state;
        }
        // stack up lineage to check circular dependencies
        state.ancestors.push(key);
        // mark row as checked
        state.checked[key] = true;
        state = objReduce(scProp.struct, createStructIterator(schema, schemaIterator, key), state);
        // add result, and fix up the stack
        state.result.push({
            name: key,
            scProp,
        });
        state.ancestors.pop();
        // check each requirement too
        return state;
    };
}
export function createStructIterator(schema, schemaIterator, key) {
    return (state, item) => {
        // skip items with no relationships
        if (!item.relation) {
            return state;
        }
        const dependsOn = item.relation.struct;
        if (state.ancestors.indexOf(dependsOn) > -1) {
            throw new Error('DB Fixer: circular dependency found: ' + key +
                ' -> ' + dependsOn);
        }
        if (state.checked[dependsOn]) {
            return state;
        }
        if (!schema[dependsOn]) {
            throw new ReferenceError('DB Fixer: unable to resolve: ' + dependsOn);
        }
        schemaIterator(state, schema[dependsOn], dependsOn);
        return state;
    };
}
export function strictifySchemaStructItem(scItem) {
    if (isSchemaType(scItem)) {
        return {
            type: scItem,
        };
    }
    return scItem;
}
export function strictifySchemaStruct(struct) {
    return objReduce(struct, (s, e, i) => {
        s[i] = strictifySchemaStructItem(e);
        return s;
    }, {});
}
export function strictifySchemaItem(scProp) {
    if (isSchemaProp(scProp)) {
        if (isSchemaStructStrict(scProp.struct)) {
            return scProp;
        }
        return Object.assign({}, scProp, {
            struct: strictifySchemaStruct(scProp.struct),
        });
    }
    return {
        struct: strictifySchemaStruct(scProp),
    };
}
export function strictify(schema) {
    return objReduce(schema, (s, e, i) => {
        s[i] = strictifySchemaItem(e);
        return s;
    }, {});
}
export function mutateStructIntoSchemaStructs(s, schema) {
    return objReduce(schema, (newSchema, item) => {
        const struct = item.struct ? item.struct : item;
        objReduce(s, augmentObjIfNew, struct);
        return newSchema;
    }, schema);
}
//# sourceMappingURL=fixer-functions.js.map