import 'rxjs/operator/concat';
import { NotInCode, NotInDb, } from '../schema';
import { listAllColumns, listTables, } from '../queries/sql';
import { isSchemaStructItem } from '../schema-guards';
import { findCaseInsensitivePropInObj, hasProp, isBoolean, objReduce, partial, pluck, } from '../../util';
import { createColumnName, typeCheckColumn } from './checkers-types';
const tableName = 'table_name';
const mapTableName = partial(pluck, tableName);
const hasTableName = partial(hasProp, tableName);
export function listTableNames(query) {
    return listTables(query)
        .filter(hasTableName)
        .map(mapTableName);
}
export function fetchTablesAndCheckIfInCode(query, schema) {
    return listTableNames(query)
        .map(createCheckForTableInCode(schema))
        .toArray();
}
export function findColumnInSchema(schema, table, column) {
    const scProp = findCaseInsensitivePropInObj(schema, table);
    if (isBoolean(scProp)) {
        return scProp;
    }
    return findCaseInsensitivePropInObj(scProp.struct, column);
}
export function createInfoSchemaToValidationContainer(schema) {
    return (col) => {
        const c = findColumnInSchema(schema, col.table_name, col.column_name);
        if (isSchemaStructItem(c)) {
            return typeCheckColumn(c, col);
        }
        return {
            error: {
                name: createColumnName(col.table_name, col.column_name),
                reason: NotInCode,
                type: 'column',
            },
            name: createColumnName(col.table_name, col.column_name),
        };
    };
}
export function fetchColumnsAndCheckIfInCode(query, schema) {
    const filterByTable = (col) => findCaseInsensitivePropInObj(schema, col.table_name) ? true : false;
    return listAllColumns(query)
        .filter(filterByTable)
        .map(createInfoSchemaToValidationContainer(schema))
        .toArray();
}
export function createCheckForTableInCode(dict) {
    const keys = Object.keys(dict).map((k) => k.toLowerCase());
    return (collection) => {
        if (keys.indexOf(collection.toLowerCase()) === -1) {
            return {
                error: {
                    type: 'table',
                    name: collection,
                    reason: NotInCode,
                },
                name: collection,
            };
        }
        const collDict = {};
        collDict[collection] = dict[collection];
        return {
            error: undefined,
            name: collection,
        };
    };
}
export function checkForTableInDb(dict, dbTables) {
    const lcTables = dbTables.map(s => s.toLowerCase());
    return objReduce(dict, (state, schema, prop) => lcTables.indexOf(prop.toLowerCase()) === -1 ?
        state.concat([{
                type: 'table',
                name: prop,
                reason: NotInDb,
            }]) :
        state, []);
}
export function createColumnsInDbTableReducer(lcCols, sName) {
    return (innerState, colDesc, colProp) => {
        const needle = createColumnName(sName, colProp).toLowerCase();
        return lcCols.indexOf(needle) === -1 ?
            innerState.concat([{
                    type: 'column',
                    name: `${sName}.${colProp}`,
                    reason: NotInDb,
                }]) :
            innerState;
    };
}
export function createColumnsInDbReducer(dbColumns) {
    const lcCols = dbColumns.map(s => s.toLowerCase());
    return (state, scProp, prop) => objReduce(scProp.struct, createColumnsInDbTableReducer(lcCols, prop), state);
}
export function checkForColumnInDb(dict, dbColumns) {
    return objReduce(dict, createColumnsInDbReducer(dbColumns), []);
}
export function flattenSchemaValidationContainers(arr) {
    return arr.reduce((s, svc) => {
        if (svc.error) {
            s.errors.push(svc.error);
        }
        s.names.push(svc.name);
        return s;
    }, { errors: [], names: [] });
}
export function validateColumns(query, schema, svc) {
    return fetchColumnsAndCheckIfInCode(query, schema)
        .map(flattenSchemaValidationContainers)
        .map((innerSvc) => checkForColumnInDb(schema, innerSvc.names)
        .concat(innerSvc.errors)
        .concat(svc.errors));
}
export function validateTables(query, schema) {
    return fetchTablesAndCheckIfInCode(query, schema)
        .map(flattenSchemaValidationContainers)
        .map((svc) => ({
        errors: svc.errors.concat(checkForTableInDb(schema, svc.names)),
        names: svc.names,
    }));
}
//# sourceMappingURL=checker-functions.js.map