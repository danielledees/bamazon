import 'rxjs/operator/concat';
import { objReduce } from '../../util';
import { Constraint, NotInCode, TypeMismatch, } from '../schema';
import { typeMappingsByInfoSchema } from '../type-mappings';
import { strictify } from './fixer-functions';
export function compareNullConstraints(col, constraints) {
    const index = constraints.indexOf('NotNull');
    if (col.is_nullable === 'YES') {
        if (index !== -1) {
            return {
                name: col.column_name,
                type: 'type',
                reason: Constraint,
                extra: 'db: NULL code: NOT NULL',
            };
        }
    }
    else {
        if (index === -1) {
            return {
                name: col.column_name,
                type: 'type',
                reason: Constraint,
                extra: 'db: NOT NULL code: NULL',
            };
        }
    }
    return null;
}
export function compareTypes(type, col, constraints = []) {
    const mappings = typeMappingsByInfoSchema[col.data_type];
    if (Array.isArray(mappings)) {
        const match = mappings.reduce((state, el) => {
            if (state) {
                return state;
            }
            if (el.generic === type) {
                return true;
            }
            return false;
        }, false);
        if (!match) {
            return {
                name: col.column_name,
                type: 'type',
                reason: TypeMismatch,
                extra: `db: ${col.data_type} code: ${type}`,
            };
        }
        return compareNullConstraints(col, constraints);
    }
    else {
        return {
            name: col.column_name,
            type: 'type',
            reason: NotInCode,
        };
    }
}
function createSchemaValidationReducer(schema) {
    return (schemaState, scProp) => {
        return objReduce(scProp.struct, createStructValidationReducer(schema), schemaState);
    };
}
export function validateSchemaRelations(schema) {
    const sSchema = strictify(schema);
    return objReduce(sSchema, createSchemaValidationReducer(sSchema), { count: 0, string: '' }).string;
}
function createStructValidationReducer(schema) {
    return (structState, prop) => {
        if (prop.relation) {
            const relationError = findRelation(schema, prop.relation, prop.type);
            if (relationError) {
                return Object.assign({}, {
                    count: structState.count + 1,
                    string: structState.string ? '\n' + relationError : relationError,
                });
            }
        }
        return structState;
    };
}
export function findRelation(s, r, type) {
    if (s[r.struct]) {
        const prop = s[r.struct].struct[r.prop];
        if (prop) {
            if (prop.type === type) {
                return '';
            }
            return `Prop ${r.prop} on ${r.struct} is of type ${prop.type} but ` +
                `relationship specifies ${type}`;
        }
        return `Prop ${r.prop} not found in Structure ${r.struct}`;
    }
    return `Structure "${r.struct}" not found`;
}
export function typeCheckColumn(schemaStructProp, col) {
    const diff = compareTypes(schemaStructProp.type, col, schemaStructProp.constraints);
    if (diff) {
        diff.name = createColumnName(col.table_name, diff.name);
        return {
            error: diff,
            name: createColumnName(col.table_name, col.column_name),
        };
    }
    return {
        error: undefined,
        name: col.table_name + '.' + col.column_name,
    };
}
export function createColumnName(tableName, columnName) {
    return `${tableName}.${columnName}`;
}
//# sourceMappingURL=checkers-types.js.map