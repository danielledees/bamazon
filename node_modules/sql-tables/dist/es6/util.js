const chalk = require('chalk');
export function arrToObj(arr, prop, aggregate) {
    return arr.reduce((state, el, i) => {
        let index;
        if (!prop) {
            index = i;
        }
        else {
            index = el[prop];
        }
        if (aggregate) {
            if (!state[index]) {
                state[index] = [];
            }
            state[index].push(el);
        }
        else {
            state[index] = el;
        }
        return state;
    }, {});
}
export function objEach(d, callback) {
    Object.keys(d).forEach((key, i) => {
        callback(d[key], key, i, d);
    });
}
export function objFilter(d, callback) {
    return objReduce(d, (state, value, key, index) => {
        if (callback(value, key, index)) {
            state[key] = value;
        }
        return state;
    }, {});
}
export function objReduce(d, callback, init) {
    return Object.keys(d)
        .reduce((state, key, i) => {
        return callback(state, d[key], key, i, d);
    }, init);
}
/**
 *  If keys/values have different lengths the expect behavior is to "underflow"
 *  values.  Non values will be initialized to undefined. Non keys will be
 *  ignored.
 *
 *  If there are duplicate keys the last assignment "wins", this would be the
 *  key with the highest index in the given keys array
 */
export function zip(keys, values) {
    return keys.reduce((o, key, i) => {
        o[key] = values[i];
        return o;
    }, {});
}
export function unzip(dictionary) {
    return Object.keys(dictionary)
        .reduce((s, val) => {
        s.keys.push(val);
        s.values.push(dictionary[val]);
        return s;
    }, {
        keys: [],
        values: [],
    });
}
export function toString(val) {
    return val + '';
}
export function toStringMax(max, val) {
    const v = toString(val);
    return v.length > max ? v.slice(0, max) : v;
}
export function toIntMin(min, val) {
    const num = toInt(val);
    if (num < min) {
        return min;
    }
    return num;
}
export function toIntMax(max, val) {
    const num = toInt(val);
    if (num > max) {
        return max;
    }
    return num;
}
export function toGtZeroIntMax(max, val) {
    const num = toInt(val);
    if (num > max) {
        return max;
    }
    if (num < 0) {
        return 0;
    }
    return num;
}
export function partial(f, ...boundArg) {
    return (...args) => f(...boundArg, ...args);
}
export function identity(i) {
    return i;
}
export function toSqlBoolean(val) {
    if (val) {
        return 'TRUE';
    }
    return 'FALSE';
}
export function toJsBoolean(val) {
    return val;
}
export function toInt(val) {
    return parseInt(val, 10);
}
export function toIntBetween(min, max, val) {
    const asInt = toInt(val);
    if (asInt < min) {
        return min;
    }
    if (asInt > max) {
        return max;
    }
    return asInt;
}
export function toIntBetweenOptional(min, max, val) {
    if ((min === undefined) && (max === undefined)) {
        return val;
    }
    if (min === undefined) {
        return toIntMax(max, val);
    }
    if (max === undefined) {
        return toIntMin(min, val);
    }
    return toIntBetween(min, max, val);
}
export function deepFreeze(obj) {
    if (Array.isArray(obj)) {
        return Object.freeze(obj.map(deepFreeze));
    }
    if (isObject(obj)) {
        for (let i in obj) {
            if (isObject(obj[i])) {
                if (!Object.isFrozen(obj[i])) {
                    obj[i] = deepFreeze(obj[i]);
                }
            }
        }
    }
    return Object.freeze(obj);
}
/**
 * Is the given value a truthy object?
 */
export function isObject(obj) {
    if (!obj) {
        return false;
    }
    return typeof obj === 'object';
}
export function isString(input) {
    return typeof input === 'string';
}
export function error(...messages) {
    console.log.call(console, chalk.red(messages.join(' ')));
}
export function sql(...messages) {
    if (process.env.SQLT_HIDE_SQL) {
        return;
    }
    console.log.call(console, chalk.blue(messages.join(' ')));
}
export function log(...messages) {
    console.log.apply(console, messages);
}
export function noop() { }
export function nullableInt(val) {
    if (val === null) {
        return val;
    }
    return toInt(val);
}
export function warn(...args) {
    console.warn.apply(console, args);
}
export function isBoolean(arg) {
    if (typeof arg === 'boolean') {
        return true;
    }
    return false;
}
export function findCaseInsensitivePropInObj(obj, prop) {
    const lProp = prop.toLowerCase();
    return objReduce(obj, (obj, el, objProp) => {
        if (obj) {
            return obj;
        }
        if (lProp === objProp.toLowerCase()) {
            return el;
        }
        return false;
    }, false);
}
export function pluck(prop, haystack) {
    return haystack[prop];
}
export function hasProp(prop, haystack) {
    return haystack[prop] ? true : false;
}
export function augmentObjIfNew(obj, item, key) {
    if (obj[key]) {
        // skip over
        return obj;
    }
    obj[key] = item;
    return obj;
}
//# sourceMappingURL=util.js.map