import { Client, Pool, Query, QueryResult } from 'pg';
import { Observable } from 'rxjs';
import { SchemaStrict, SchemaStructStrict, SchemaStructProp, SchemaType } from './schema/schema';
export declare const getClient: () => Observable<Client>;
export declare const isValidResult: (result: QueryResult) => boolean;
export interface QueryObservable {
    (queryString: string, params?: any[]): Observable<QueryResult>;
}
export interface QueryStream<T> {
    (queryString: string, params?: any[]): Observable<T>;
}
export declare type QueryFunction<T> = QueryObservable | QueryStream<T>;
export interface TableRow {
    id: number;
}
export declare function getClientFrom(p: () => Pool): Observable<Client>;
export declare function createPgQuery(client: Client, queryString: string, params?: any[]): Query & Promise<QueryResult>;
/**
 * Internal function to create a query that returns an observable that emits
 * rows one at a time
 */
export declare function createQueryStream<T>(client: Client, queryString: string, params?: any[]): Observable<T>;
/**
 * Internal function to create a query that returns its _entire_ result as an
 * observable
 */
export declare function createQueryObservable(client: Client, queryString: string, params?: any[]): Observable<QueryResult>;
export declare function queryStream<T>(queryString: string, params?: any[]): Observable<T>;
export declare function query(queryString: string, params?: any[]): Observable<QueryResult>;
export declare function getStruct(schema: SchemaStrict, tableName: string): SchemaStructStrict;
export declare function propSchemaToSql(prop: SchemaStructProp, value: any): string | number;
export declare function propToSql(prop: SchemaType | SchemaStructProp, value: any): any;
export declare function validatePropValsForInput(struct: SchemaStructStrict, cols: string[], vals: any[]): {
    cols: any[];
    vals: any[];
};
export declare function createSelectWhereQuery(name: string, cols: string[]): string;
export declare function createInsertQuery(name: string, cols: string[], vals: any[]): string;
export declare function createUpdateQuery(name: string, cols: string[], vals: any[], idProps: string[]): string;
export declare function createDeleteQuery(name: string, idProps: string[]): string;
export declare function createSelectAllQuery(name: string, cols?: string[]): string;
export declare function selectWhereValidator(schema: SchemaStrict, tableName: string, cols: string[], vals: any[]): Error | SchemaStructStrict;
/**
 * returns an observable that streams result rows
 */
export declare function selectWhereStream<T>(schema: SchemaStrict, tableName: string, cols: string[], vals: any[]): Observable<T>;
export declare function selectStream<T>(schema: SchemaStrict, tableName: string, cols?: string[]): Observable<T>;
/**
 * returns an observable with the _entire_ result
 */
export declare function selectWhereObservable(schema: SchemaStrict, tableName: string, cols: string[], vals: any[]): Observable<QueryResult>;
export declare function insert<T>(schema: SchemaStrict, tableName: string, colsOrObject: string[] | {
    [P in keyof T]?: T[P];
}, vals?: any[]): Observable<QueryResult>;
export declare function update<T>(schema: SchemaStrict, tableName: string, idProps: string[], idValues: Array<number | string>, colsOrObject: string[] | {
    [P in keyof T]?: T[P];
}, vals?: any[]): Observable<QueryResult>;
export declare function deleteFrom(schema: SchemaStrict, tableName: string, idProps: string[], idValues: Array<number | string>): Observable<QueryResult>;
export declare function reduceByKeys(keys: number[]): (cols: string[], col: string, i: number) => string[];
export declare function hasQueryError(first: number, result: any[], i: number): number;
export declare function createReduceCompoundInsertOrSelectResults(depCols: string[]): (results: TableRow[][]) => number[];
export declare function compoundInsertOrSelectIfExists(schema: SchemaStrict, tableName: string, cols: string[], vals: any[], depObservables: Observable<TableRow[]>[], depCols: string[], ...keyIndexes: number[]): Observable<TableRow[]>;
export declare function insertOrSelectIfExistsObservable<T extends TableRow>(schema: SchemaStrict, tableName: string, cols: string[], vals: any[], ...keyIndexes: number[]): Observable<T[]>;
export declare function transactionStart(isolationLevel?: string): Observable<QueryResult>;
export declare function transactionEnd(): Observable<QueryResult>;
export declare function transactionRollBack(err?: Error): Observable<QueryResult>;
export declare type SqlCrud<T> = {
    [P in keyof T]: {
        insert(thing: {
            [P1 in keyof T[P]]?: T[P][P1];
        }): Observable<QueryResult>;
        update(idProps: string[], idVals: Array<number | string>, obj: {
            [P1 in keyof T[P]]?: T[P][P1];
        }): Observable<QueryResult>;
        delete(idProps: string[], idVals: Array<number | string>): Observable<QueryResult>;
        select(): Observable<T[P]>;
        selectWhere(idProps: string[], idVals: Array<number | string>): Observable<T[P]>;
    };
};
export declare function createCrud<T>(schema: SchemaStrict): SqlCrud<T>;
